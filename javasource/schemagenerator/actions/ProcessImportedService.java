// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package schemagenerator.actions;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.mendix.core.Core;
import com.mendix.http.Http;
import com.mendix.http.HttpHeader;
import com.mendix.http.HttpMethod;
import com.mendix.http.HttpResponse;
import com.mendix.integration.ShouldCommit;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IFeedback;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserException;
import com.mendix.webui.CustomJavaAction;
import com.mendix.webui.FeedbackHelper;
import org.apache.http.HttpStatus;
import schemagenerator.proxies.InterimServicesToBeImported;
import schemagenerator.proxies.ODataSchema;
import schemagenerator.proxies.OdataSchemaDocument;
import schemagenerator.proxies.constants.Constants;
import schemagenerator.proxies.microflows.Microflows;
import tcconnector.proxies.Cookie;
import tcconnector.proxies.TcSession;

public class ProcessImportedService extends CustomJavaAction<IMendixObject>
{
	private IMendixObject __serviceZip;
	private schemagenerator.proxies.OdataSchemaDocument serviceZip;
	private java.lang.Boolean askConformationForOverwrite;

	public ProcessImportedService(IContext context, IMendixObject serviceZip, java.lang.Boolean askConformationForOverwrite)
	{
		super(context);
		this.__serviceZip = serviceZip;
		this.askConformationForOverwrite = askConformationForOverwrite;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		this.serviceZip = this.__serviceZip == null ? null : schemagenerator.proxies.OdataSchemaDocument.initialize(getContext(), __serviceZip);

		// BEGIN USER CODE
		InputStream serviceZipStream = Core.getFileDocumentContent(getContext(), serviceZip.getMendixObject());
		serviceZip.delete();
	
		ZipInputStream serviceZipInputStream = new ZipInputStream(serviceZipStream);
		ZipEntry entry = serviceZipInputStream.getNextEntry();
		if (entry == null) {
			FeedbackHelper.addCloseCallerFeedback(getContext());
			throw new UserException(UserException.ExceptionCategory.Custom, "Schema File is not valid");
		}
		ArrayList<String> servicesFound = new ArrayList<>();
		ArrayList<String> servicesAlreadyPresent = new ArrayList<>();

		InterimServicesToBeImported servicesToBeImported = new InterimServicesToBeImported(getContext());

		TcSession tcSession = tcconnector.proxies.microflows.Microflows.retrieveTcSessionBasedOnConfigName(getContext(),null);
		IMendixObject mendixCookie = Core.retrieveByPath(getContext(), tcSession.getMendixObject(), "TcConnector.Cookies").get(0);
		Cookie cookie = Cookie.initialize(getContext(), mendixCookie);
		HttpHeader cookieHeader = new HttpHeader("Cookie", cookie.getName() + '=' + cookie.getValue());

		ArrayList<ODataSchema> servicesToCheck = new ArrayList<>();

		while(entry != null) {
			if (entry.isDirectory()) {
				entry = serviceZipInputStream.getNextEntry();
				continue;
			}
			String nameOfEntry = entry.getName();
			if (nameOfEntry.endsWith("/TcMapping.json")) {
				String nameOfService = nameOfEntry.split("/")[0];
				String serviceVersion = nameOfEntry.split("/")[1];

				if (!serviceVersion.matches("^[v][0-9]+$")) {
					FeedbackHelper.addCloseCallerFeedback(getContext());
					throw new UserException(UserException.ExceptionCategory.Custom, "The Service Version: '" + serviceVersion + "' is not of the required format (v<major_version> eg v1)");
				}
				OdataSchemaDocument serviceSchemaDocument = new OdataSchemaDocument(getContext());
				
				serviceSchemaDocument.setmajorVersion(getContext(), serviceVersion);
				serviceSchemaDocument.setName(getContext(), nameOfService);
				byte[] buf = serviceZipInputStream.readAllBytes();
				String entryString = new String(buf, StandardCharsets.UTF_8);
				ByteArrayInputStream serviceStream = new ByteArrayInputStream(buf);

				List<IMendixObject> services = Core.retrieveXPathQuery(getContext(), "//SchemaGenerator.OdataSchemaDocument" + "[Name = '" + nameOfService + "'][majorVersion = '" + serviceVersion + "']");
				if (!services.isEmpty()) {
					if (OdataSchemaDocument.initialize(getContext(), services.get(0)).getdeployed()) {
						Http httpHandler = Core.http();

						URI getCsdlUrl = new URI(
							tcSession.getHostAddress(getContext()) + "/" + 
							Constants.getAppendMicroServiceURL() + "/" +
							VALIDATE_MINOR_VERSION_CHANGES + "?" +
							"schemaVersion=" + serviceVersion +
							"&schemaName=" + nameOfService
						);
						HttpResponse resp = httpHandler.executeHttpRequest(
							getCsdlUrl,
							HttpMethod.POST, 
							new HttpHeader[]{cookieHeader},
							serviceStream
						);
						if (resp.getStatusCode() != HttpStatus.SC_OK) {
							List<IMendixObject> toDeleteServices = Core.retrieveByPath(getContext(), servicesToBeImported.getMendixObject(), "SchemaGenerator.OdataSchemaDocument_InterimServicesToBeImported");
							toDeleteServices.add(servicesToBeImported.getMendixObject());
							Core.delete(getContext(), toDeleteServices);
							FeedbackHelper.addCloseCallerFeedback(getContext());
							throw new UserException(UserException.ExceptionCategory.Custom, "The Service is not compatible with the one deployed");
						}
					}
					servicesAlreadyPresent.add(nameOfService);
				}
				serviceSchemaDocument.setminorVersion(getContext(), -1);
				serviceSchemaDocument.setOdataSchemaDocument_InterimServicesToBeImported(getContext(), servicesToBeImported);
				
				try {
					ValidateSchema validateSchema = new ValidateSchema(getContext(), entryString);
					validateSchema.executeAction();
				} catch (Exception ex) {
					Core.delete(getContext(), serviceSchemaDocument.getMendixObject());
					FeedbackHelper.addCloseCallerFeedback(getContext());
					throw ex;
				}

				serviceStream.reset();
				Core.storeFileDocumentContent(
					getContext(),
					serviceSchemaDocument.getMendixObject(),
					serviceStream
				);

				ODataSchema odataSchema = ODataSchema.initialize(getContext(), new ImportServiceFromJSON (
						getContext(),
						serviceSchemaDocument.getMendixObject(),
						null,
						schemagenerator.proxies.ShouldCommit.No.toString()
				).executeAction());

				if(odataSchema == null)
				{
					serviceSchemaDocument.delete();
					FeedbackHelper.addCloseCallerFeedback(getContext());
					throw new UserException(UserException.ExceptionCategory.Custom, "Error occurred while importing the service.");
				}

				odataSchema.setContractName(getContext(), nameOfService);
				servicesToCheck.add(odataSchema);

//				try {
//					ValidateService validateService = new ValidateService(getContext(), odataSchema.getMendixObject());
//					validateService.executeAction();
//				} catch (Exception e) {
//					serviceSchemaDocument.delete();
//					Core.delete(getContext(), serviceSchemaDocument.getMendixObject());
//					FeedbackHelper.addCloseCallerFeedback(getContext());
//					throw e;
//				}
				
				Core.commit(getContext(), serviceSchemaDocument.getMendixObject());
				servicesFound.add(nameOfService);
			}
			entry = serviceZipInputStream.getNextEntry();
		}
		serviceZipInputStream.closeEntry();
		serviceZipInputStream.close();
		serviceZipStream.close();

		try {
			for (ODataSchema schema: servicesToCheck) {
				ValidateService validateService = new ValidateService(getContext(), schema.getMendixObject());
				validateService.executeAction();
			}
		} catch (Exception e) {
			Core.delete(getContext(), servicesToCheck.stream().map(ODataSchema::getMendixObject).collect(Collectors.toList()));
			FeedbackHelper.addCloseCallerFeedback(getContext());
			throw e;
		}

		StringBuilder stringBuilder = new StringBuilder();

		if (servicesFound.isEmpty()) {
			FeedbackHelper.addCloseCallerFeedback(getContext());
			throw new UserException(UserException.ExceptionCategory.Custom, "No Suitable Service Found in file");
		}
		if (servicesAlreadyPresent.isEmpty()) {
			ImportOrOverwrite importOrOverwriteAction = new ImportOrOverwrite(getContext(), servicesToBeImported.getMendixObject());
			importOrOverwriteAction.execute();
			FeedbackHelper.addCloseCallerFeedback(getContext());
			return null;
		}
		else {
			stringBuilder.append("The Following service(s) will be overwritten\nDo you want to continue ?\n");
			for (String string : servicesAlreadyPresent) {
				stringBuilder.append("\t" + string + "\n");
			}
		}
		servicesToBeImported.setMessage(getContext(), stringBuilder.toString());

		FeedbackHelper.addCloseCallerFeedback(getContext());

		return servicesToBeImported.getMendixObject();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ProcessImportedService";
	}

	// BEGIN EXTRA CODE
	private static final String VALIDATE_MINOR_VERSION_CHANGES = "validateMinorVersionChanges";
	// END EXTRA CODE
}
